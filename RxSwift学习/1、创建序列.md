### Observable - 可被监听的序列

Observable 可以用于描述元素异步产生的序列

- Observable<T> 这个类就是 Rx 框架的基础，我们可以称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<T> 对象会随着时间推移不定期地发出 event(element : T) 这样一个东西。
- 而且这些 Event 还可以携带数据，它的泛型 <T> 就是用来指定这个 Event 携带的数据的类型
- 有了可观察序列，我们还需要有一个 Observer（订阅者）来订阅它，这样这个订阅者才能收到 Observable<T> 不时发出的 Event。
 
 #### Event - 事件
 ```
 public enum Event<Element> {
 case next(Element)
 case error(Swift.Error)
 case completed
 }
 ```
    next - 序列产生了一个新的元素
    error - 创建序列时产生了一个错误，导致序列终止
    completed - 序列的所有元素都已经成功产生，整个序列已经完成




#### DisposeBag - 清除包

因为我们用的是 Swift ，所以我们更习惯于使用 ARC 来管理内存。那么我们能不能用 ARC 来管理订阅的生命周期了。答案是肯定了，你可以用 清除包（DisposeBag） 来实现这种订阅管理机制。当 清除包 被释放的时候，清除包 内部所有 可被清除的资源（Disposable） 都将被清除



#### 如何创建序列

创建序列最直接的方法就是调用 Observable.create，然后在构建函数里面描述元素的产生过程

##### create方法

该方法接受一个 block 形式的参数，任务是对每一个过来的订阅进行处理。

代码
```
let observable = Observable<Any>.create { (observer) -> Disposable in

observer.onNext("测试create1")
observer.onNext("测试create2")
observer.onNext("测试create3")
observer.onCompleted()

return Disposables.create()
}

//订阅测试
observable.subscribe(onNext: { (result) in
print(result)
}, onError: { (error) in
print(error)
}, onCompleted: {
print("结束")
}).disposed(by: disposeBag)
```
打印结果
```
测试create1
测试create2
测试create3
结束
```


##### just方法

 该方法通过传入一个默认值来初始化。
 ![just](https://github.com/SunshineBrother/JHBlog/blob/master/RxSwift学习/rxswift图片/just.png)
下面样例我们显式地标注出了 observable 的类型为 Observable<Int>，即指定了这个 Observable 所发出的事件携带的数据类型必须是 Int 类型的。

核心代码
```
let observable = Observable<Int>.just(5)

其实它是相当于

let id = Observable<Int>.create { observer in
observer.onNext(5)
observer.onCompleted()
return Disposables.create()
}
```

全部代码
```
func setUPJust(){
let observable = Observable<Int>.just(5)
observable.subscribe(onNext: { (result) in
print(result)
}, onError: { (error) in

}, onCompleted: {
print("结束")
}).disposed(by: disposeBag)
}
```

打印结果
```
5
结束
```

##### from方法

将其他类型或者数据结构转换为 Observable

当你在使用 Observable 时，如果能够直接将其他类型转换为 Observable，这将是非常省事的。from 操作符就提供了这种功能。


 ![from](https://github.com/SunshineBrother/JHBlog/blob/master/RxSwift学习/rxswift图片/from.png)

将一个数组转换为 Observable：
```
let numbers = Observable.from([1,2,3,4,5])
```
它相当于：
```
let numbers = Observable<Int>.create { observer in
observer.onNext(1)
observer.onNext(2)
observer.onNext(3)
observer.onNext(4)
observer.onNext(5)
observer.onCompleted()
return Disposables.create()
}
```


```
func setUPFrom() {
//        let observable = Observable.from([1,2,3,4,5])
let observable = Observable.from(["1":"one","2":"two"])

observable.subscribe(onNext: { (result) in
print(result)
}, onError: { (error) in

}, onCompleted: {
print("结束")
}).disposed(by: disposeBag)

}
```
打印结果1
```
1
2
3
4
5
结束
```
打印结果2
```
(key: "2", value: "two")
(key: "1", value: "one")
结束
```
from有两个方法，想看的可以点进去看一看
```
public static func from(_ array: [Self.E], scheduler: ImmediateSchedulerType = default) -> RxSwift.Observable<Self.E>


public static func from<S>(_ sequence: S, scheduler: ImmediateSchedulerType = default) -> RxSwift.Observable<Self.E> where S : Sequence, Self.E == S.Element
```














